[
["index.html", "Topics in data analytics Intro to R 1 Getting familiar with R &amp; RStudio 1.1 Projects", " Topics in data analytics Intro to R Bruna Wundervald 1 Getting familiar with R &amp; RStudio 1.1 Projects "],
["the-tidyverse.html", "2 The tidyverse 2.1 The pipe operator", " 2 The tidyverse The tidyverse is a collection o R packages designed to make data science as easy and clear as possible. It is mostly maintained by people who work at RStudio, but it also receives many collaborations from the community. The term “collection” means that when you load the tidyverse, you actually load many packages at the same time, which are dplyr: data manipulation tidyr: tidy data ggplot2: grammar of graphics readr: reading rectangular data stringr: functions for string data forcats: functions for factor data purrr: functional programming tibble: modern data.frames Such packages are built to work cohesively together. To install and load the tidyverse, just run install.packages(&quot;tidyverse&quot;) library(tidyverse) The tidyverse ecossystem intends to provide a toolkit for the full data science workflow in R, illustrated in Figure 1. The above mentioned packages are not the only ones in the ecossystem. In reality, there is a big tidy-wave happening now in the R community, so there are numerous new packages coming up everyday that work with and follow the same philosophy of the tidyverse. Figure 2.1: Data science workflow: from importing data to communication The open book “R for Data Science”, written by Hadley Wickham &amp; Garrett Grolemund, is available and it can be really interesting for learning more about the tidyverse in practice and its philosophy. Figure 2.2: Book: R for Data Science, Hadley Wickham &amp; Garrett Grolemund 2.1 The pipe operator A key component of the tidyverse ecossystem is the pipe (or %&gt;%) operator. The operator works by applying to the object that is on its left side, the function that comes on its right side. For example, we can find the mean of a vector by doing 1:20 %&gt;% mean() [1] 10.5 This is useful because we can chain many operation layers in a logical order (the order that they actually happen) using the %&gt;%, which makes the code much easier to write for who’s writing it, and much more readable for who’s trying to understand it. In the following we will see many more examples of the %&gt;% being used. Figure 2.3: The pipe operator in the magrittr package sticker. "],
["reading-data.html", "3 Reading data 3.1 the data is available at [etc] 3.2 Reading .xlsx files 3.3 Reading .csv files 3.4 Reading .txt files", " 3 Reading data In this section we will briefly approach a few ways of reading rectangular data into R. This task is usually accomplished with base/native functions and, when the data files are a bit more complex, with the help of other packages. In general data science, some common data file extensions are: .xlsx (Excel file) .csv (comma-separated files) .txt (text files) 3.1 the data is available at [etc] We will examine a dataset on M&amp;M sweets. The color counts and net weight (in grams) for a sample of 30 bags of M&amp;M was recorded. The advertised net weight per bag is 47.9 grams. 3.2 Reading .xlsx files mm1 &lt;- readxl::read_xlsx(&quot;data/MandM.xlsx&quot;) head(mm1) # A tibble: 6 x 7 Red Green Blue Orange Yellow Brown Weight &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 15 9 3 3 9 19 49.8 2 9 17 19 3 3 8 49.0 3 14 8 6 8 19 4 50.4 4 15 7 3 8 16 8 49.2 5 10 3 7 9 22 4 47.6 6 12 7 6 5 17 11 49.8 3.3 Reading .csv files mm2 &lt;- read_csv(&quot;data/MandM.csv&quot;) head(mm2) # A tibble: 6 x 7 Red Green Blue Orange Yellow Brown Weight &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 15 9 3 3 9 19 49.8 2 9 17 19 3 3 8 49.0 3 14 8 6 8 19 4 50.4 4 15 7 3 8 16 8 49.2 5 10 3 7 9 22 4 47.6 6 12 7 6 5 17 11 49.8 3.4 Reading .txt files mm3 &lt;- read_table2(&quot;data/MandM.txt&quot;, col_names = FALSE) names(mm3) &lt;- c(&quot;Red&quot;, &quot;Green&quot;, &quot;Blue&quot;, &quot;Orange&quot;, &quot;Yellow&quot;, &quot;Brown&quot;, &quot;Weight&quot;) head(mm3) # A tibble: 6 x 7 Red Green Blue Orange Yellow Brown Weight &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 15 9 3 3 9 19 49.8 2 9 17 19 3 3 8 49.0 3 14 8 6 8 19 4 50.4 4 15 7 3 8 16 8 49.2 5 10 3 7 9 22 4 47.6 6 12 7 6 5 17 11 49.8 They all look the same! And this is the summary of this dataset: summary(mm3) Red Green Blue Orange Min. : 3.0 Min. : 2.0 Min. : 1.000 Min. : 0.000 1st Qu.: 6.5 1st Qu.: 6.0 1st Qu.: 4.000 1st Qu.: 4.000 Median : 9.0 Median : 7.0 Median : 6.500 Median : 6.000 Mean : 9.6 Mean : 7.4 Mean : 7.233 Mean : 6.633 3rd Qu.:12.0 3rd Qu.: 9.0 3rd Qu.: 9.750 3rd Qu.: 9.000 Max. :20.0 Max. :17.0 Max. :19.000 Max. :13.000 Yellow Brown Weight Min. : 3.00 Min. : 4.00 Min. :46.22 1st Qu.: 8.25 1st Qu.: 8.00 1st Qu.:48.29 Median :13.50 Median :12.50 Median :49.07 Mean :13.77 Mean :12.47 Mean :49.21 3rd Qu.:18.00 3rd Qu.:17.75 3rd Qu.:50.17 Max. :26.00 Max. :20.00 Max. :52.06 "],
["data-cleaning-manipulation-with-dplyr.html", "4 Data cleaning &amp; manipulation with dplyr 4.1 Manipulation 4.2 Cleaning", " 4 Data cleaning &amp; manipulation with dplyr The dplyr package is arguably the most important/useful one of the tidyverse group of packages. It provides us with the “Grammar of Manipulation” that make the most common data manipulation tasks easy &amp; consistently written. The term “Grammar” comes from the fact that the tidyverse functions, in general, are built to work as “verbs” in a sentence. 4.1 Manipulation The core functions of the dplyr are: mutate(): adding and changing variables select(): pick or drop variables filter(): filter the data according to some defined rule summarise: reduces the data to a single value (such as the mean, maximum and minimum, etc) arrange(): ordering data group_by(): perform the above operations taking into account one or more grouping variables These functions, again, comprise basically the main data manipulation tasks we always end up doing when dealing with a new dataset. In the following, we have a few examples of the functions in action: # Finding summary measures of the package weight mm3 %&gt;% summarise(mean_weight = mean(Weight), sd_weight = sd(Weight)) %&gt;% mutate(lb_mean = mean_weight - 1 * sd_weight, ub_mean = mean_weight + 1 * sd_weight) # A tibble: 1 x 4 mean_weight sd_weight lb_mean ub_mean &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 49.2 1.52 47.7 50.7 If the advertised net weight per bag is 47.9 grams, can we easily test if the data agrees with that? mm3 %&gt;% summarise(mean_weight = mean(Weight), sd_weight = sd(Weight), # We can calculate the p-value of a t-test for the # mean being equal to 47.9 and save it as a # summary variable: p.value = t.test(Weight, mu = 47.9)$p.value ) %&gt;% # Now, is this p-value lower than 0.05 (95% level of significance)? mutate(is_mean_equal = ifelse(p.value &lt; 0.05, &quot;Evidence against&quot;, &quot;Evidence in favour&quot;)) # A tibble: 1 x 4 mean_weight sd_weight p.value is_mean_equal &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; 1 49.2 1.52 0.0000535 Evidence against We had checked before that the orange M&amp;M’s were less common. Could that be related with a change in the mean weight? # We can either separate the data: mm3 %&gt;% filter(Orange &lt;= 4) %&gt;% summarise(mean_weight = mean(Weight), sd_weight = sd(Weight), p.value = t.test(Weight, mu = 47.9)$p.value) # A tibble: 1 x 3 mean_weight sd_weight p.value &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 49.4 1.66 0.0287 mm3 %&gt;% filter(Orange &gt; 4) %&gt;% summarise(mean_weight = mean(Weight), sd_weight = sd(Weight), p.value = t.test(Weight, mu = 47.9)$p.value) # A tibble: 1 x 3 mean_weight sd_weight p.value &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 49.1 1.50 0.00108 # Or create a grouping variable: mm3 %&gt;% mutate(orange_low = ifelse(Orange &lt;= 4, &quot;Low&quot;, &quot;Normal&quot;)) %&gt;% group_by(orange_low) %&gt;% summarise(mean_weight = mean(Weight), sd_weight = sd(Weight), p.value = t.test(Weight, mu = 47.9)$p.value) # A tibble: 2 x 4 orange_low mean_weight sd_weight p.value &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 Low 49.4 1.66 0.0287 2 Normal 49.1 1.50 0.00108 # Or use some other heuristic, such as filtering by the 10 lowest # orange values mm3 %&gt;% arrange(Orange) %&gt;% slice(1:10) %&gt;% summarise(mean_weight = mean(Weight), sd_weight = sd(Weight), p.value = t.test(Weight, mu = 47.9)$p.value) # A tibble: 1 x 3 mean_weight sd_weight p.value &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 49.4 1.57 0.0138 Those are more or less simple operations to find some statistics about the data. However, the dplyr has its own website where many more information and resources can be found: https://dplyr.tidyverse.org/ Besides that, the dplyr functions also have many handy extensions such as the: _all(): performs an operation is all columns _at: performs an operation at some specific columns _if performs an operation if a condition is satisfied 4.2 Cleaning Very frequently, before actually starting our analysis, we first need to clean our data. This means we need to fix possible errors, adding or removing information, formatting it, always trying to be the most thorough possible in order to avoid. Let us consider now a second dataset from a typical clinical trial with continuous and characted variables, that will require a bit more of cleaning. A few other packages will be used in combination with the dplyr, especially the stringr and forcats. # Just reading the data pt &lt;- read.table(&quot;data/Patients.csv&quot;, header = TRUE, sep = &quot;,&quot;) # Showing the types and first rows of the data.frame pt %&gt;% glimpse() Observations: 31 Variables: 8 $ PATNO &lt;fct&gt; 1, 2, 3, 4, XX5, 6, 7, , 8, 9, 10, 11, 12, 13, 14, 2, 3, … $ GENDER &lt;fct&gt; M, F, X, F, M, , M, M, F, M, f, M, M, 2, M, F, M, F, F, M… $ VISIT &lt;fct&gt; 11/11/1998, 11/13/1998, 10/21/1998, 01/01/1999, 05/07/199… $ HR &lt;int&gt; 88, 84, 68, 101, 68, 72, 88, 90, 210, 86, NA, 68, 60, 74,… $ SBP &lt;int&gt; 140, 120, 190, 200, 120, 102, 148, 190, NA, 240, 40, 300,… $ DBP &lt;int&gt; 80, 78, 100, 120, 80, 68, 102, 100, NA, 180, 120, 20, 74,… $ DX &lt;fct&gt; 1, X, 3, 5, 1, 6, , , 7, 4, 1, 4, , 1, , X, , 3, 2, , 1, … $ AE &lt;fct&gt; 0, 0, 1, A, 0, 1, 0, 0, 0, 1, 0, 1, 0, , 1, 0, 0, 1, 0, 0… # Fixing the names of the columns names(pt) &lt;- str_to_lower(names(pt)) # Finding frequency tables per gender pt %&gt;% count(gender) # A tibble: 6 x 2 gender n &lt;fct&gt; &lt;int&gt; 1 &quot;&quot; 1 2 2 1 3 f 2 4 F 12 5 M 14 6 X 1 The first problem was found: the gender column is not standardized, as we have both lower and upper cases and an empty level. This is easily fixable with the help of functions from the stringr package: pt &lt;- pt %&gt;% # Transform lower cases to upper cases in gender mutate(gender = str_to_upper(gender)) %&gt;% # Replacing the empty or strange information for something more useful mutate(gender = ifelse(gender %in% c(&quot;&quot;, &quot;2&quot;, &quot;X&quot;), &quot;Not Available&quot;, gender)) # View the frequency table again pt %&gt;% count(gender) # A tibble: 3 x 2 gender n &lt;chr&gt; &lt;int&gt; 1 F 14 2 M 14 3 Not Available 3 # Now it makes more sense! However, we still can spot a few problems. For instance, the variable names visit was read as factor, while we now that it should be interpreted as a date. We can use the lubridate package to fix in situations like this. # Transforming the variable into a date type pt &lt;- pt %&gt;% mutate(visit = as.Date(visit, &quot;%m/%d/%Y&quot;), day = lubridate::day(visit), month = lubridate::month(visit), month_year = zoo::as.yearmon(visit)) # Check that it is transformed class(pt$visit) [1] &quot;Date&quot; # How many observations we have each month? pt %&gt;% count(month) # A tibble: 13 x 2 month n &lt;dbl&gt; &lt;int&gt; 1 1 2 2 2 1 3 3 1 4 4 1 5 5 2 6 6 2 7 7 1 8 8 2 9 9 1 10 10 4 11 11 6 12 12 1 13 NA 7 –&gt; Exercises: https://teachingr.com/content/the-5-verbs-of-dplyr/the-5-verbs-of-dplyr-exercise.html "],
["plotting-data-with-ggplot2.html", "5 Plotting data with ggplot2", " 5 Plotting data with ggplot2 After preparing the data, we can start creating some plots to actually extract some information from it (or find even more things to be fixed). The ggplot2 package is based on The Grammar of Graphics, and provides us with the tools to create whatever graph we need. As defined by the creator of the package, Hadley Wickham, a plot is composed by 4 things: Layers: data, aesthetics (aes), geometric objects (geom), transformations, etc Scales Coordinates Facets So the ggplot2 syntax creates plots by especifically using a combination of these 4 elements. This might not make much sense now but it is actually quite easy to understand. For instance, we can create a barplot of the month count we saw above with: count_month &lt;- pt %&gt;% count(month) %&gt;% mutate(month = as.factor(month)) p &lt;- count_month %&gt;% # In the aes() function we map the variables from the data # into the x, y and other dimensions of the plot ggplot(aes(x = month, y = n)) + # The geom_ layers define what type of graphic we want geom_bar(stat = &quot;identity&quot;) + # The geom_ can be accumulated, by simply adding more layers to the # plot geom_point(colour = &quot;blue&quot;) p How can we make this nicer? Maybe changing colours, labels and other details: p + # Adding the variable labelling labs(x = &quot;Month of the year&quot;, y = &quot;Number of occurrences&quot;) + # Using a built-in theme with font size 14 theme_minimal(14) Or we can just suppress all the labs by an informative title: p + geom_point(colour = &quot;blue&quot;) + labs(title = &quot;Number of occurrences of \\neach month&quot;, x = &quot;&quot;, y = &quot;&quot;) + theme_minimal(14) Can we change the order of the bars? (but note that it won’t be in the month order anymore!) p &lt;- count_month %&gt;% mutate(month = as.factor(month)) %&gt;% # In the aes() function we map the variables from the data # into the x, y and other dimensions of the plot ggplot(aes(x = reorder(month, n), y = n)) + # The geom_ layers define what type of graphic we want geom_bar(stat = &quot;identity&quot;, colour = &quot;black&quot;, fill = &quot;grey95&quot;) + # The geom_ can be accumulated, by simply adding more layers to the # plot geom_point(colour = &quot;blue&quot;) + labs(title = &quot;Number of occurrences of \\neach month&quot;, x = &quot;&quot;, y = &quot;&quot;) + theme_minimal(14) p The NA class is the most frequent one, but we don’t know what it means. We can just remove it, for example: p &lt;- count_month %&gt;% mutate(month = as.factor(month)) %&gt;% na.omit() %&gt;% # In the aes() function we map the variables from the data # into the x, y and other dimensions of the plot ggplot(aes(x = reorder(month, n), y = n)) + # The geom_ layers define what type of graphic we want geom_bar(stat = &quot;identity&quot;, colour = &quot;black&quot;, fill = &quot;grey95&quot;) + # The geom_ can be accumulated, by simply adding more layers to the # plot geom_point(colour = &quot;blue&quot;) + labs(title = &quot;Number of occurrences of \\neach month&quot;, x = &quot;&quot;, y = &quot;&quot;) + theme_minimal(14) p Could we make the same plot per gender? count_month_gender &lt;- pt %&gt;% group_by(gender) %&gt;% count(month) %&gt;% mutate(month = as.factor(month)) %&gt;% na.omit() p &lt;- count_month_gender %&gt;% # In the aes() function we map the variables from the data # into the x, y and other dimensions of the plot ggplot(aes(x = reorder(month, n), y = n)) + # The geom_ layers define what type of graphic we want geom_bar(stat = &quot;identity&quot;, colour = &quot;black&quot;, fill = &quot;grey95&quot;) + # The geom_ can be accumulated, by simply adding more layers to the # plot facet_wrap(~gender, ncol = 1) + geom_point(aes(colour = gender)) + labs(title = &quot;Number of occurrences of each month, \\nper gender&quot;, x = &quot;&quot;, y = &quot;&quot;) + theme_minimal(14) p –&gt; Exercises: https://r4ds.had.co.nz/data-visualisation.html#exercises "],
["functional-programming.html", "6 Functional Programming 6.1 Modelling", " 6 Functional Programming 6.1 Modelling "],
["time-series.html", "7 Time Series", " 7 Time Series "],
["text-mining.html", "8 Text Mining", " 8 Text Mining "],
["r-markdown.html", "9 R markdown", " 9 R markdown An R Markdown file is a plain text file that has the extension .Rmd, and is a full authoring framework for data science. You can use a single R Markdown file to:rmark save and execute code generate high quality reports (papers, products, etc) Figure 9.1: R Markdown An .Rmd file contains the elements: An (optional) YAML header surrounded by ---s R code chunks surrounded by ``s (also works for other languages likePythonandJulia`) Text mixed with figures, code, etc Titles ad subtitles created by hashtags The results of code chunks Latex, equations, bold and italic text (a complete formatting tool) "],
["references.html", "10 References", " 10 References "]
]
